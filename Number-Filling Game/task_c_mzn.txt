%NOIP2018-S D2T2
%input

int: n;
int: m;

%desctiption

int: max_mn=product(i in m..m+n-2)(i) div product(i in 1..n-1)(i);
int: max_t=pow(2,m*n);
array[1..max_t,1..n,1..m] of var 0..1: table;
array[1..max_mn,1..m+n-2] of var 0..1: direction;
array[1..max_t,1..max_mn,1..m+n-1] of var 0..1: track;

constraint forall(i,j in 1..max_t where i!=j)(not(forall(x in 1..n,y in 1..m)(table[i,x,y]=table[j,x,y])));
constraint forall(i in 1..max_mn)(count(j in 1..m+n-2)(direction[i,j]=0)=n-1 /\ count(j in 1..m+n-2)(direction[i,j]=1)=m-1);
constraint forall(i,j in 1..max_mn where i!=j)(not(forall(k in 1..m+n-2)(direction[i,k]=direction[j,k])));

function array[1..m+n-1] of var 0..1: get_track(array[1..n,1..m] of var 0..1: t, array[1..m+n-2] of var 0..1: d)=
let{
array[1..m+n-1] of var 0..1: tmp;
constraint tmp[1]=t[1,1] /\ tmp[m+n-1]=t[n,m];
%è¿™æ¡è·¯å¾„ä»ŽçŸ©å½¢è¡¨æ ¼çš„å·¦ä¸Šè§’çš„æ ¼å­(0,0)å‡ºå‘ï¼Œåˆ°çŸ©å½¢çš„å³ä¸‹è§’æ ¼å­(n âˆ’ 1, m âˆ’ 1)ç»“æŸï¼›
constraint forall(i in 1..m+n-2)(tmp[i]=t[count(j in 1..i-1)(d[j]=0)+1,count(j in 1..i-1)(d[j]=1)+1]);
%å°†æ¯æ¡åˆæ³•è·¯å¾„ P ç»è¿‡çš„æ¯ä¸ªæ ¼å­ä¸Šå¡«å…¥çš„æ•°å­—ä¾æ¬¡è¿žæŽ¥åŽï¼Œä¼šå¾—åˆ°ä¸€ä¸ªé•¿åº¦ä¸ºn + m âˆ’ 1çš„ 01 å­—ç¬¦ä¸²
} in tmp;

predicate larger(array[1..m+n-2] of var 0..1: d1,array[1..m+n-2] of var 0..1: d2)=
exists(i in 1..m+n-2)(forall(k in 1..i-1)(d1[k]=d2[k]) /\ d1[i]>d2[i]);
%æˆ‘ä»¬è¯´å­—ç¬¦ä¸² a æ¯”å­—ç¬¦ä¸² b å°ï¼Œå½“ä¸”ä»…å½“å­—ç¬¦ä¸² a çš„å­—å…¸åºå°äºŽå­—ç¬¦ä¸² b çš„å­—å…¸åº

constraint forall(t in 1..max_t)(forall(i in 1..max_mn)(track[t,i,1..m+n-1]=get_track(table[t,1..n,1..m],direction[i,1..m+n-2])));
array[1..max_t] of var 0..1: ans;
constraint forall(t in 1..max_t)
(if forall(i,j in 1..max_mn where i!=j /\ larger(direction[i,1..m+n-2],direction[j,1..m+n-2]))
(larger(track[t,i,1..m+n-2],track[t,j,1..m+n-2])) then ans[t]=1 else ans[t]=0 endif);
%ä½¿å¾—å¯¹äºŽä¸¤æ¡è·¯å¾„ð‘ƒ1ï¼ŒP2ï¼Œå¦‚æžœw(P1) >w(P2)ï¼Œé‚£ä¹ˆå¿…é¡»s(P1) â‰¤ s(P2)

%solve

solve satisfy;

%output

output[show(sum(ans))];



