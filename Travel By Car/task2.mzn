%NOIP2012-S D1T3
%input

int: N;
array[1..N] of int: H;
int: X0;
int: M;
array[1..M] of int: S;
array[1..M] of int: X;

%description

function var int: d(var int: i,var int: j) =
abs(H[i]-H[j]);
%åŸå¸‚ i å’ŒåŸå¸‚ j ä¹‹é—´çš„è·ç¦» d[i,j]æ°å¥½æ˜¯è¿™ä¸¤ä¸ªåŸå¸‚æµ·æ‹”é«˜åº¦ä¹‹å·®çš„ç»å¯¹å€¼ï¼Œå³d[i, j] = |ğ»ğ‘– âˆ’ ğ»ğ‘—|ã€‚

predicate near(var int: d1, var int: d2, var int: H1, var int: H2) =
d1 < d2 \/ (d1 == d2 /\ H1 < H2);
%æœ¬é¢˜ä¸­å¦‚æœå½“å‰åŸå¸‚åˆ°ä¸¤ä¸ªåŸå¸‚çš„è·ç¦»ç›¸åŒï¼Œåˆ™è®¤ä¸ºç¦»æµ·æ‹”ä½çš„é‚£ä¸ªåŸå¸‚æ›´è¿‘

function var int: plan_B(var int: current_city) = 
let{
var 1..N: nearest;
constraint if current_city<N then nearest > current_city else nearest=N+1 endif;
%ä¸€ç›´å‘ä¸œè¡Œé©¶
constraint forall(i in current_city+1..N where i!=nearest)(near(d(current_city,nearest),d(current_city,i),H[nearest],H[i]));
} in nearest;
%å° B æ€»æ˜¯æ²¿ç€å‰è¿›æ–¹å‘é€‰æ‹©ä¸€ä¸ªæœ€è¿‘çš„åŸå¸‚ä½œä¸ºç›®çš„åœ°
%N+1ä¸ºç»“æŸæ—…è¡Œ

function var int: plan_A(var int: current_city) = 
let{
var 1..N: second_near;
var 1..N: nearest;
constraint if current_city < N-1 then second_near > current_city /\ nearest > current_city /\ second_near!= nearest else second_near=N+1 /\ nearest=N endif;
constraint forall(i in current_city+1..N where i!=nearest)(near(d(current_city,nearest),d(current_city,i),H[nearest],H[i]));
constraint forall(i in current_city+1..N where (i!=nearest /\ i!=second_near))(near(d(current_city,second_near),d(current_city,i),H[second_near],H[i]));
} in second_near;
%å° A æ€»æ˜¯æ²¿ç€å‰è¿›æ–¹å‘é€‰æ‹©ç¬¬äºŒè¿‘çš„åŸå¸‚ä½œä¸ºç›®çš„åœ°
%N+1ä¸ºç»“æŸæ—…è¡Œ

function array[1..2] of var int: travel(var int: start_city, var int: limit) =
let{
array[0..N] of var 1..N+1: route;
var 0..N-1: days;
constraint route[0]=start_city;
constraint forall(i in 1..days)(route[i] < N+1);
constraint forall(i in 1..days)(if i mod 2==1 then route[i]=plan_A(route[i-1]) else route[i]=plan_B(route[i-1]) endif);
%å° A å’Œå° B è½®æµå¼€è½¦ï¼Œç¬¬ä¸€å¤©å° A å¼€è½¦ï¼Œä¹‹åæ¯å¤©è½®æ¢ä¸€æ¬¡
constraint sum(i in 1..days)(d(route[i],route[i-1])) <= limit;
%å¦‚æœå…¶ä¸­ä»»ä½•ä¸€äººæ— æ³•æŒ‰ç…§è‡ªå·±çš„åŸåˆ™é€‰æ‹©ç›®çš„åŸå¸‚ï¼Œæˆ–è€…åˆ°è¾¾ç›®çš„åœ°ä¼šä½¿è¡Œé©¶çš„æ€»è·ç¦»è¶…å‡º X å…¬é‡Œï¼Œä»–ä»¬å°±ä¼šç»“æŸæ—…è¡Œã€‚
array[1..2] of var int: total_distance;
constraint total_distance[1]=sum(i in 1..days where i mod 2==1)(d(route[i],route[i-1]));
constraint total_distance[2]=sum(i in 1..days where i mod 2==0)(d(route[i],route[i-1]));

} in total_distance;

function var float: cal_ratio(var int: d1,var int: d2) =
if d2==0 then 10000
else d1/d2 endif;
%å¦‚æœå° B çš„è¡Œé©¶è·¯ç¨‹ä¸º 0ï¼Œæ­¤æ—¶çš„æ¯”å€¼å¯è§†ä¸ºæ— ç©·å¤§ï¼Œä¸”ä¸¤ä¸ªæ— ç©·å¦‚æœå° B çš„è¡Œé©¶è·¯ç¨‹ä¸º 0ï¼Œæ­¤æ—¶çš„æ¯”å€¼å¯è§†ä¸ºæ— ç©·å¤§ï¼Œä¸”ä¸¤ä¸ªæ— ç©·å¤§è§†ä¸ºç›¸ç­‰


array[1..N,1..2] of var int: distance_s0;
constraint forall(i in 1..N)(distance_s0[i,1..2]=travel(i,X0));

array[1..N] of var float: ratio ::is_defined_var;
constraint forall(i in 1..N)(ratio[i]=cal_ratio(distance_s0[i,1],distance_s0[i,2]) ::defines_var(ratio[i]));

%solve

solve maximize sum(i in 1..M,j in 1..2)(distance_s0[i,j]);

%output

output[show(i) | i in 1..N where forall(j in 1..N where j!=i)(fix(ratio[i])<fix(ratio[j]) \/ (fix(ratio[i])==fix(ratio[j]) /\ H[i]>H[j]))];
%å¦‚æœä»å¤šä¸ªåŸå¸‚å‡ºå‘ï¼Œå° A å¼€è½¦è¡Œé©¶çš„è·¯ç¨‹æ€»æ•°ä¸å° B è¡Œé©¶çš„è·¯ç¨‹æ€»æ•°çš„æ¯”å€¼éƒ½æœ€å°ï¼Œåˆ™è¾“å‡ºæµ·æ‹”æœ€é«˜çš„é‚£ä¸ªåŸå¸‚ã€‚

